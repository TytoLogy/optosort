classdef SpikeInfo
%------------------------------------------------------------------------
% TytoLogy:Experiments:opto...
%------------------------------------------------------------------------

%------------------------------------------------------------------------
%  Sharad J. Shanbhag
%	sshanbhag@neomed.edu
%------------------------------------------------------------------------
% Created: ? 2020 (SJS)
%
% Revisions:
%  7 Sep 2023 (SJS): adding referenceMode property to store common
%                    referencing status for data
%------------------------------------------------------------------------
% TO DO: how to handle multiple channels?????
%------------------------------------------------------------------------

	properties
		% FileName		nex file name (include path)
		% InfoFileName	nexinfo filename (incluedes path)
		% FileInfo		array of CurveInfo objects 
		% Fs				samples/sec for data
		% sweepStartBin	{nfiles, 1} holding arrays of sample for start of
		%						each data recording sweep
		% sweepEndBin		{nfiles, 1} holding arrays of sample for end of
		%						each data recording sweep
		% fileStartBin		[nfiles, 1] sample for start of
		%						each data file within .nex file
		% fileEndBin		[nfiles, 1] sample for end of
		%						each data file within .nex file
		% startBinVector	[total # sweeps, 1] sample for start of each sweep
		% endBinVector	[total # sweeps, 1] sample for end of each sweep
		% ADchannel		list of AD channels exported within .nex file
      % dataFilter
      % referenceMode   'raw', 'average', 'median'
		FileName
		InfoFileName
 		FileInfo
		Fs
		sweepStartBin = {};
		sweepEndBin = {};
		fileStartBin
		fileEndBin
		startBinVector
		endBinVector
		% stimStart, stimEnd
		stimStartBin = {};
		stimEndBin = {};
		ADchannel
		dataFilter
      referenceMode = '';
	end	% END properties (main)
	properties (Dependent)
		fileStartTime
		fileEndTime
		sweepStartTime
		sweepEndTime
		stimStartTime
		stimEndTime
		startTimeVector
		endTimeVector
		stimStartTimeVector
		stimEndTimeVector
		% stimStartTime, stimEndTime
		nFiles
	end	% END properties(Dependent)
	
	methods
		%-------------------------------------------------
		%-------------------------------------------------
		% Constructor
		%-------------------------------------------------
		%-------------------------------------------------
		function obj = SpikeInfo(varargin)
			if isempty(varargin)
				return
			end
			if length(varargin) == 2
				if strcmpi(varargin{1}, 'struct')
					% this might be deprecated/removed in future
					obj = obj.initFromNexInfoStruct(varargin{2});
				elseif strcmpi(varargin{1}, 'file')
					obj = obj.initFromNexInfoFile(varargin{2});
				else
					error('Unknown input type %s', varargin{1});
				end
			else
				error('need both input mode and input value');
			end
		end

		%-------------------------------------------------
		%-------------------------------------------------
		% utility methods
		%-------------------------------------------------
		%-------------------------------------------------

		%-------------------------------------------------
		% initialize from NexInfo struct... remove????
		%-------------------------------------------------
		function obj = initFromNexInfoStruct(obj, nexInfo)
			obj.FileName = nexInfo.NexFileName;
			obj.Fs = nexInfo.Fs;
			obj.sweepStartBin = nexInfo.sweepStartBin;
			obj.sweepEndBin = nexInfo.sweepEndBin;
			obj.fileStartBin = nexInfo.fileStartBin;
			obj.fileEndBin = nexInfo.fileEndBin;
		end
		
		%-------------------------------------------------
		% initialize from NexInfo file (generated by export_for_plexon)
		%-------------------------------------------------
		function obj = initFromNexInfoFile(obj, nexInfoFileName) %#ok<INUSL>
% 			obj = load(nexInfoFileName, 'nexInfo');
%			obj = load(nexInfoFileName);
			if ~exist(nexInfoFileName, 'file')
				error('nexinfo file %s not found', nexInfoFileName);
			else
				tmpStruct = load(nexInfoFileName, 'nexInfo');
				obj = tmpStruct.nexInfo;
				clear tmpStruct
			end
		end
		
		%-------------------------------------------------
		% get # of data channels stored in file
		%-------------------------------------------------
		function val = nChannels(obj)
			val = length(obj.ADchannel);
		end

		
		%-------------------------------------------------
		% Stimulus Information (stimcache)
		%-------------------------------------------------
		function val = getStimulusCacheByFile(obj, filenum)
			% see if filenum is in bounds
			if ~between(filenum, 1, obj.nFiles)
				error('filenum out of range [1 %d]', obj.nFiles);
			end
			
			val = obj.FileInfo(filenum).Dinf.test.stimcache;
			% check to see if character fields are stored as chars or need to
			% be converted from ASCII integers
			charfields = {'stimtype', 'curvetype', 'vname'};
			for f = 1:length(charfields)
				if ~ischar(val.(charfields{f}))
					val.(charfields{f}) = char(val.(charfields{f}));
				end
			end
		end
		
		
		%-------------------------------------------------
		% Stimulus Onset/offset by type
		%-------------------------------------------------
% 		function val = getStimOnOffByType(obj)
% 			
% 			
% 		end
		%-------------------------------------------------------
		function events = stimEventTimesForFile(obj, fileNum, varargin)
		%-------------------------------------------------------
		% get array of event structs for given file
		%	events		struct array with fields:
		%		name
		%		samples
		%		timestamps
		%-------------------------------------------------------
			alignMode = 'FILE';
			
			if ~isempty(varargin)
				if any(strcmpi(varargin{1}, {'FILE', 'ORIG'}))
					alignMode = varargin{1};
				else
					error('SpikeInfo.stimEventTimesForFile: invalid mode %s', ...
									varargin{1});
				end
			end
			
			% get events for the given file/test
			events = obj.FileInfo{fileNum}.geteventList;
			
			switch upper(alignMode)
				case 'FILE'
					% get onset of file
					offsetbin = obj.fileStartBin(fileNum);
					
				case 'ORIG'
					offsetbin = 1;
			end
			% convert samples to timestamps, aligned
			% 1) loop through nevents
			for n = 1:length(events)
				% 2) event times  are ebins + (filestartbin -1) / sampling rate
				events(n).timestamps = ((offsetbin - 1) + events(n).samples) ...
							./ obj.Fs;
			end
		end
		%-------------------------------------------------------
		
		%-------------------------------------------------
		%-------------------------------------------------
		% access for dependent properties
		%-------------------------------------------------
		%-------------------------------------------------
		
		%-------------------------------------------------
		% # of files merged into nex file
		%-------------------------------------------------
		function val = get.nFiles(obj)
			val = length(obj.FileInfo);
		end
		%-------------------------------------------------
		% fileStart, end Time computed from bins
		%-------------------------------------------------
		function val = get.fileStartTime(obj)
			val = (1/obj.Fs) * (obj.fileStartBin - 1);
		end
		function val = get.fileEndTime(obj)
			val = (1/obj.Fs) * (obj.fileEndBin - 1);
		end
		%-------------------------------------------------		
		% convert sweep bin cells to vectors... 
		%-------------------------------------------------
		function val = get.startBinVector(obj)
			val = [obj.sweepStartBin{:}];
		end
		function val = get.endBinVector(obj)
			val = [obj.sweepEndBin{:}];
		end
		%-------------------------------------------------
		% sweep Start, end Time computed from bins
		%-------------------------------------------------
		function val = get.sweepStartTime(obj)
			val = cell(obj.nFiles, 1);
			for f = 1:obj.nFiles
				val{f} = (obj.sweepStartBin{f} - 1) * (1/obj.Fs);
			end
		end
		function val = get.sweepEndTime(obj)
			val = cell(obj.nFiles, 1);
			for f = 1:obj.nFiles
				val{f} = (obj.sweepEndBin{f} - 1) * (1/obj.Fs);
			end
		end
		% and as a single vector
		function val = get.startTimeVector(obj)
			val = (obj.startBinVector - 1) * (1/obj.Fs);
		end
		function val = get.endTimeVector(obj)
			val = (obj.endBinVector - 1) * (1/obj.Fs);
		end
		%-------------------------------------------------
		% stimulus Start, end Time computed from bins
		%-------------------------------------------------
		function val = get.stimStartTime(obj)
			val = cell(obj.nFiles, 1);
			for f = 1:obj.nFiles
				val{f} = (obj.stimStartBin{f} - 1) * (1/obj.Fs);
			end
		end
		function val = get.stimEndTime(obj)
			val = cell(obj.nFiles, 1);
			for f = 1:obj.nFiles
				val{f} = (obj.stimEndBin{f} - 1) * (1/obj.Fs);
			end
		end
		% and as a single vector
		function val = get.stimStartTimeVector(obj)
			val = [obj.stimStartTime{:}];
		end
		function val = get.stimEndTimeVector(obj)
			val = [obj.stimEndTime{:}];
		end
		
		
	end	% END methods
	
end	% END classdef
	
		